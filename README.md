# SafeP4R compiler

This repository contains:

  * In `safeP4R/`: The code for the SafeP4R API and type generator, as well as examples that use the API.
  * In `vm/`: A virtual machine that sets up a simulation network using mininet, which can be used to test the API.

## Prerequisites

__This project requires:__

  * [sbt](https://www.scala-sbt.org/) (for building the project)
  * [VirtualBox](https://www.virtualbox.org/wiki/Downloads) (for running the examples)
  * [Vagrant](https://www.vagrantup.com/) (for running the examples)

## Kick-the-Tires Guide

  1. Navigate to the `vm/` directory.
  2. Run `vagrant up` to build and run the VM. Building the VM will take 10-15 minutes.
  3. When the `vagrant` building procedure is complete, the VM will reboot.
     (From now on, you can launch the VM from VirtualBox, without using `vagrant` again.)
  4. When the VM presents a graphical log-in prompt:
      1. Log on as user __safeP4R__ with the password `safeP4R`.
      2. Open a terminal in the VM and run `make test`.
         This will start the mininet network simulation with four hosts and four switches `s1`..`s4`
         (see the `topology.json` file for the layout).
         It also applies the P4 configuration `config1` to `s1` and `s2`, and `config2` to `s3` and `s4`.
  5. Now, navigate to the `safeP4R/` directory on the **host** machine that is running the VM.
  6. Run `sbt "runMain safeP4Rtest"`. This will run the program in `src/main/scala/examples/safeP4Rtest.scala`,
     which connects to the mininet network in the VM and sends some test queries to the `s1` switch.
     If everything goes well, it will print `Test successful!` followed by `[success]`

## Project layout

The source code directory `safeP4R/src/main/scala/` contains several subfolders:

  * `protobuf/`: The "untyped" P4Runtime API code, generated by [ScalaPB](https://scalapb.github.io/docs/installation)
    from the protobuf specification (which itself is found in `safeP4R/src/protobuf/`).
  * `typegen/`: The type generator, which parses a given P4info file and outputs "equivalent" Scala 3 types.
  * `api/`: The type-parametric SafeP4R API used for making P4Runtime queries. The API is documented in the Scaladoc style.
  * `examples/`: Examples that use the SafeP4R API with generated types. Requires the VM to be running.

## Type generation

To compile a P4info file into a Scala 3 package, use

    sbt "runMain parseP4info <p4info-file> <package-name>"

where `<p4info-file>` is the absolute path of the P4info file to be compiled, and
`<package-name>` is the name of the package to be generated.
The generated Scala package is written to stdout.

In total, the package contains the following:

* Generated match types
* `Chan` class
* `connect` function

### Generated match types

This section contains the generated match types, which are also described in the paper.

As an example, consider a P4Info file with these tables and actions:

    "tables": [
      {
        "preamble": {
          "id": 50014192,
          "name": "Process.ipv4_lpm",
          "alias": "ipv4_lpm"
        },
        "matchFields": [
          {
            "id": 1,
            "name": "hdr.ipv4.dstAddr",
            "bitwidth": 32,
            "matchType": "LPM"
          }
        ],
        "actionRefs": [
          { "id": 26706864 },
          { "id": 22338797 }
        ],
        "size": "1024"
      }
    ],
    "actions": [
      {
        "preamble": {
          "id": 22338797,
          "name": "Process.drop",
          "alias": "drop"
        }
      },
      {
        "preamble": {
          "id": 26706864,
          "name": "Process.ipv4_forward",
          "alias": "ipv4_forward"
        },
        "params": [
          {
            "id": 1,
            "name": "dstAddr",
            "bitwidth": 48
          },
          {
            "id": 2,
            "name": "port",
            "bitwidth": 9
          }
        ]
      }
    ]

This would produce the following types:

    type TableMatchFields[TN] =
      TN match
        case "Process.ipv4_lpm" => (Option[("hdr.ipv4.dstAddr", LPM)]) | "*"
        case "*" => "*"
    type ActionName = "Process.drop" | "Process.ipv4_forward" | "*"

    type TableAction[TN] <: ActionName =
      TN match
        case "Process.ipv4_lpm" => "Process.ipv4_forward" | "Process.drop" | "*"
        case "*" => "*"

    type ActionParams[AN] =
      AN match
        case "Process.drop" => Unit
        case "Process.ipv4_forward" => (("dstAddr", ByteString), ("port", ByteString))
        case "*" => "*"

### `Chan` class

A `Chan` object represents a connection between a target (the switch) and a
controller (the program). The `Chan` class in the generated package inherits
the abstract `Chan` class from the `safeP4R` package, which is type parametric.
The generated `Chan` class is always instantiated with the match types from its
own package. By doing this, other type parametric SafeP4R API functions that
take `Chan` objects will have their types constrained to only the types from
the associated package, which lets the Scala compiler infer the type arguments
whitout the user having to provide them explicitly.

The `Chan` class contains two functions, `toProto` and `fromProto`, which
convert table entries from their SafeP4R representation to their underlying
"loosely-typed" protobuf representations, and vice versa.

### `connect` function

The `connect` function connects the controller to a target device, returning a
`Chan` object representing the connection.

Why is the `connect` function generated as part of a package, and not type
parametric like the other SafeP4R API functions? If it was type parametric, the
user would have to supply the types from the package explicitly, which would be
verbose and could potentially cause errors. This way, by instead having a
`connect` for each package, we hide the complexity from the user and only
require them to know the package that corresponds to the configuration of the
switch they are trying to connect to.

## Reproducing the examples in the companion paper

The instructions for running all examples are given below.  In general, each example can be run by using

    sbt "runMain <main-function>"

where `<main-function>` is the `@main` function to be run
(usually named the same as the example file itself).

### IMPORTANT: before you try any of the examples below

All provided examples require the SafeP4R VM to be running.  **Moreover**, each example assumes
a clean configuration where the network switches have no preconfigured table entries.

For this reason, **before and in-between running any of the examples below**, you need to perform
the following steps on the VM:
1. if the mininet network simulation is already running, close it (Ctrl+d);
2. run `make clean`;
3. run `make build`;
4. run `make network`.

### Testing the effect of running the examples
All of the examples affect the connectivity of the network to some degree.
To verify that the examples have had any effect, the `ping` command can be used
in the mininet interface:

   h1 ping h2

`h1` will then attempt to periodically send packets to `h2`. The sending of
packets can be stopped with Ctrl+c. If packets are successfully sent (_and_
replies are received), you should get an output similar to this:

    mininet> h1 ping h2
    PING 10.0.2.2 (10.0.2.2) 56(84) bytes of data.
    64 bytes from 10.0.2.2: icmp_seq=1 ttl=62 time=6.15 ms
    64 bytes from 10.0.2.2: icmp_seq=2 ttl=62 time=3.43 ms
    64 bytes from 10.0.2.2: icmp_seq=3 ttl=62 time=3.27 ms
    ...

If the ping is not successful, the command will appear to hang, with no output
being generated.

### Simple IPv4 table update (Fig. 1)

The example can be found in `safeP4R/src/main/scala/examples/forward_c1.scala`
(with the erroneous, non-compiling code commented out) and can be run by using

    sbt "runMain forward_c1"

__Effect__: The program will insert table entries for `s1` and `s2` such that
`h1` and `h2` can communicate with (ping) each other.

### Second simple table update

The example can be found in `safeP4R/src/main/scala/examples/forward_c2.scala`
and can be run by using

    sbt "runMain forward_c2"

__Effect__: The program will insert table entries for `s3` and `s4` such that
`h3` and `h4` can communicate with (ping) each other.

### Multi-switch update (Fig. 16)

The example can be found in `safeP4R/src/main/scala/examples/firewall.scala` and can be run by using

    sbt "runMain firewall"

__Effect__: The program will insert table entries into the `firewall` table in
each switch, causing packets with destination addresses to `h1` or `h4` to be
dropped. Effectively, this means that communication is only possible between
`h2` and `h3`.

### Full connectivity

The example can be found in `safeP4R/src/main/scala/examples/bridge.scala` and can be run by using

    sbt "runMain bridge"

__Effect__: The program will insert table entries for all switches such that
each host can communicate with any other host.

## Creating a new scenario

We now provide an small example to demonstrate how updating/extending a P4 configuration can cause
existing P4Runtime programs to "go out of sync".  Our SafeP4R API can detect these
situations and produce type errors, thus preventing incorrect P4Runtime programs from compiling and running.

  1. In the VM, open the `/home/safeP4R/config1.p4` file, and rename the `ipv4_forward` action
     in line 95 and 119 to `ipv4_transfer` (or make any other structural change of your choice).
  2. Recompile the P4 file and P4Info file by running `make clean` followed by `make build`.
     This will generate a new P4Info file in `/home/safeP4R/build/config1.p4.p4info.json`.
  3. Copy the contents of the new P4Info file onto a file in your host machine, such as
     `safeP4R/safeP4R/src/main/scala/examples/config1_new.p4info.json`.
  4. Generate new types from the P4info file. If you use the file above, the command will look like

      sbt "runMain parseP4info safeP4R/src/main/scala/examples/config1_new.p4info.json config1_new"

  5. Create a new Scala file `config1_new.scala` in the `example/` directory, then place the
     newly generated types in that file.
  6. In `forward_c1.scala`, replace `config1` in line 6 and 7 with `config1_new`.
  7. Try to compile the program. It should fail, reporting an error around line 12:
     this reflects the fact that the code does not match the updated P4 configuration
     (it is accessing a table called `ipv4_forward`, but the table is now called `ipv4_transfer`).
  9. Fix the program by changing `"Process.ipv4_forward"` in line 12 to `"Process.ipv4_transfer"`.
     The program should then compile.
